plugins {
    id 'groovy'
    id 'org.springframework.boot' version '3.2.1'
    id 'io.spring.dependency-management' version '1.1.4'
}

java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(17)
    }
}

group = 'org.example'
version = '1.0-SNAPSHOT'

repositories {
    // Repozytorium, z którego Gradle pobierze biblioteki (Spocka i Groovy)
    mavenCentral()
}

dependencies {
    // Baza: Silnik Groovy 4.0 (kompatybilny z JDK 17)
    implementation 'org.apache.groovy:groovy-all:4.0.15'

    // Baza: Spock Framework - zestaw dla Groovy 4.0
    testImplementation platform('org.spockframework:spock-bom:2.3-groovy-4.0')
    testImplementation 'org.spockframework:spock-core'

    implementation 'org.codehaus.gpars:gpars:1.2.1'

    // Dodaj Byte\-Buddy, aby Spock mógł tworzyć Spy/Mock dla klas (nie tylko interfejsów)
    implementation("net.bytebuddy:byte-buddy:1.18.4")

    implementation 'io.github.http-builder-ng:http-builder-ng-core:1.0.4'

    // Potrzebne do uruchamiania testów Spock (opartych na JUnit 5)
    testRuntimeOnly 'org.junit.platform:junit-platform-launcher'

    implementation 'com.h2database:h2:2.2.224'

    // --- NOWE: Spring Boot Core (Dla @Service, @Component, @Autowired) ---
    // Używamy wersji 3.x, która wymaga Javy 17 (którą masz)
    implementation 'org.springframework.boot:spring-boot-starter:3.2.1'

    // --- NOWE: Spring Boot Test (Dla @SpringBootTest, @MockBean) ---
    testImplementation 'org.springframework.boot:spring-boot-starter-test:3.2.1'

    // --- NOWE: Spock + Spring Integration (Kluczowe dla Lab 18!) ---
    // To pozwala Spockowi rozumieć kontekst Springa
    testImplementation 'org.spockframework:spock-spring:2.3-groovy-4.0'


    // Jeśli nie masz Springa w projekcie, normalnie byś go tu miał.
    // Zakładamy symulację lub dodaj:
    implementation 'org.springframework.boot:spring-boot-starter:3.1.0'

    // CLI oparty jest na potężnej bibliotece Picocli
    // Ta biblioteka pozwala tworzyć interfejsy wiersza poleceń z minimalnym nakładem kodu
    testImplementation 'org.apache.groovy:groovy-cli-picocli:4.0.15'
}

test {
    // Spock 2.x wymaga użycia platformy JUnit
    useJUnitPlatform()

    testLogging {
        events "passed", "skipped", "failed"
    }
}


// lab6_automatyzacja
// Rejestrujemy nowy task o nazwie 'generateBuildInfo'
tasks.register('generateBuildInfo') {
    group = 'praktyki'
    description = 'Generuje plik z informacjami o buildzie'

    doLast {
        def reportFile = file("${buildDir}/build-info.txt")

        // Magia Groovy: tworzymy treść używając Multiline String i interpolacji
        def info = """
            BUILD REPORT
            ------------
            Project: ${project.name}
            Version: ${project.version}
            Date: ${new Date().format('yyyy-MM-dd HH:mm:ss')}
            Java Version: ${System.getProperty('java.version')}
            Groovy Version: ${GroovySystem.version}
        """.stripIndent()

        // Zapis do pliku jedną komendą
        reportFile.parentFile.mkdirs()
        reportFile.text = info

        println ">>> Raport wygenerowany w: ${reportFile.path}"
    }
}

tasks.register('generateBuildInfo2') {
    group = 'praktyki2'
    description = 'Generuje zaawansowany raport o projekcie z wykorzystaniem logiki Groovy'

    doLast {
        // 1. Sprawdzanie czy folder testów istnieje (Zadanie: Połączenie klocków)
        def testFolder = file("src/test/groovy")
        def testsFound = testFolder.exists() ? "TAK" : "NIE"

        // 2. Safe Navigation Operator (?.) - Zadanie: Wykorzystanie bezpiecznej nawigacji
        def envTag = System.getProperty('custom.env')?.toUpperCase() ?: "DEVELOPMENT"

        // 3. Budowanie treści raportu (GString + interpolacja)
        def reportFile = new File(buildDir, "final-report.txt")

        def reportContent = """
            =========================================
            PROJEKT: ${project.name.toUpperCase()}
            =========================================
            Data buildu:    ${new Date().format('dd.MM.yyyy HH:mm')}
            Środowisko:     ${envTag}
            Testy Groovy:   ${testsFound}
            -----------------------------------------
            Statystyki plików:
            - Klasy Java:   ${fileTree('src/main/java').files.size()}
            - Klasy Groovy: ${fileTree('src/main/groovy').files.size()}
            =========================================
        """.stripIndent()

        // 4. Zapis do pliku (Groovy File Sugar)
        reportFile.parentFile.mkdirs()
        reportFile.text = reportContent

        println "------------------------------------------"
        println ">>> Finałowy raport został wygenerowany!"
        println ">>> Lokalizacja: ${reportFile.absolutePath}"
        println ">>> Wynik testów w raporcie: ${testsFound}"
        println "------------------------------------------"
    }
}

tasks.register('runLogAnalyzer', JavaExec) {
    group = 'Execution'
    description = 'Uruchamia LogAnalyzer z parametrami przy użyciu Java 17'

    classpath = sourceSets.main.runtimeClasspath
    mainClass.set('LogAnalyzer')

    // WYMUSZENIE JAVA 17: Mówimy taskowi, żeby pobrał javę z toolchaina projektu
    def toolchainService = project.extensions.getByType(JavaToolchainService)
    javaLauncher.set(toolchainService.launcherFor(java.toolchain))

    if (project.hasProperty('appArgs')) {
        args(project.getProperty('appArgs').split('\\s+'))
    }
}

// Rejestracja taska dla narzędzia LogMasker
tasks.register('runLogMasker', JavaExec) {
    group = 'Execution'
    description = 'Uruchamia narzędzie LogMasker do anonimizacji logów'

    // 1. Wskazujemy klasę główną
    mainClass.set('LogMasker')

    // 2. Ustawiamy classpath (wszystkie biblioteki i skompilowany kod)
    classpath = sourceSets.main.runtimeClasspath

    // 3. WYMUSZENIE JAVA 17 (Rozwiązanie błędu wersji Javy)
    def toolchainService = project.extensions.getByType(JavaToolchainService)
    javaLauncher.set(toolchainService.launcherFor(java.toolchain))

    // 4. Przekazywanie parametrów z terminala (-PappArgs)
    if (project.hasProperty('appArgs')) {
        args(project.getProperty('appArgs').split('\\s+'))
    }
}